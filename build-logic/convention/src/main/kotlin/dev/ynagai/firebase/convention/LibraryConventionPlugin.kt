package dev.ynagai.firebase.convention

import com.android.build.api.dsl.androidLibrary
import org.gradle.api.Plugin
import org.gradle.api.Project
import org.gradle.api.artifacts.VersionCatalogsExtension
import org.gradle.api.tasks.Exec
import org.gradle.kotlin.dsl.configure
import org.gradle.kotlin.dsl.getByType
import org.gradle.kotlin.dsl.register
import org.gradle.kotlin.dsl.withType
import org.jetbrains.kotlin.gradle.dsl.JvmTarget
import org.jetbrains.kotlin.gradle.dsl.KotlinMultiplatformExtension
import org.jetbrains.kotlin.gradle.plugin.mpp.KotlinNativeTarget

class LibraryConventionPlugin : Plugin<Project> {
    @Suppress("UnstableApiUsage")
    override fun apply(target: Project) {
        with(target) {
            with(pluginManager) {
                apply("com.android.kotlin.multiplatform.library")
                apply("org.jetbrains.kotlin.multiplatform")
            }
            val libs = extensions.getByType<VersionCatalogsExtension>().named("libs")
            extensions.configure<KotlinMultiplatformExtension> {
                androidLibrary {
                    compileSdk =
                        libs.findVersion("android-compileSdk").get().requiredVersion.toInt()
                    minSdk = libs.findVersion("android-minSdk").get().requiredVersion.toInt()
                    compilerOptions {
                        jvmTarget.set(JvmTarget.JVM_21)
                    }
                }
                iosArm64()
                iosSimulatorArm64()
                sourceSets.apply {
                    androidMain.dependencies {
                        implementation(
                            project.dependencies.platform(
                                libs.findLibrary("firebase-bom").get()
                            )
                        )
                    }
                }
            }
        }
    }
}

fun Project.configureAppleBridge(schemeName: String) {
    val nativeWrapperDir = rootProject.layout.projectDirectory.dir("native/firebase-apple-bridge")
    val baseDerivedDataDir = layout.buildDirectory.dir("DerivedData/${schemeName}")
    fun getDerivedDataPath(isSimulator: Boolean) =
        baseDerivedDataDir.map { it.dir(if (isSimulator) "Simulator" else "Device") }
    val buildAppleBridgeDevice = tasks.register<Exec>("buildAppleBridgeDevice") {
        group = "build"
        description = "Builds the $schemeName framework for iOS Device"
        val derivedDataPath = getDerivedDataPath(isSimulator = false)
        inputs.dir(nativeWrapperDir)
        outputs.dir(derivedDataPath)
        workingDir = nativeWrapperDir.asFile
        commandLine(
            "xcodebuild", "build",
            "-scheme", schemeName,
            "-configuration", "Release",
            "-destination", "generic/platform=iOS",
            "-derivedDataPath", derivedDataPath.get().asFile.absolutePath,
            "SKIP_INSTALL=NO",
            "BUILD_LIBRARY_FOR_DISTRIBUTION=YES"
        )
    }
    val buildAppleBridgeSimulator = tasks.register<Exec>("buildAppleBridgeSimulator") {
        group = "build"
        description = "Builds the $schemeName framework for iOS Simulator"
        val derivedDataPath = getDerivedDataPath(isSimulator = true)
        inputs.dir(nativeWrapperDir)
        outputs.dir(derivedDataPath)
        workingDir = nativeWrapperDir.asFile
        commandLine(
            "xcodebuild", "build",
            "-scheme", schemeName,
            "-configuration", "Release",
            "-destination", "generic/platform=iOS Simulator",
            "-derivedDataPath", derivedDataPath.get().asFile.absolutePath,
            "SKIP_INSTALL=NO",
            "BUILD_LIBRARY_FOR_DISTRIBUTION=YES"
        )
    }
    extensions.configure<KotlinMultiplatformExtension> {
        targets.withType<KotlinNativeTarget>().configureEach {
            val target = this
            val isSimulator = target.name.contains("Simulator", ignoreCase = true)
            compilations.getByName("main") {
                val cinterop = cinterops.create(project.name) {
                    definitionFile.set(project.file("src/appleMain/cinterop/${project.name}.def"))
                    val derivedDataPath = getDerivedDataPath(isSimulator)
                    val platformSuffix = if (isSimulator) "iphonesimulator" else "iphoneos"
                    val platformName = "Release-$platformSuffix"
                    val productsDir = derivedDataPath.map { it.dir("Build/Products/$platformName") }
                    val productsDirPath = productsDir.get().asFile.absolutePath
                    val packageFrameworksDirPath = productsDir.get().dir("PackageFrameworks").asFile.absolutePath

                    // GeneratedModuleMaps contains the module map and Swift headers generated by xcodebuild
                    val generatedModuleMapsDir = derivedDataPath.map {
                        it.dir("Build/Intermediates.noindex/GeneratedModuleMaps-$platformSuffix")
                    }
                    val generatedModuleMapsDirPath = generatedModuleMapsDir.get().asFile.absolutePath
                    val moduleMapPath = generatedModuleMapsDir.get().file("$schemeName.modulemap").asFile.absolutePath

                    compilerOpts(
                        "-fmodules",
                        "-fmodule-map-file=$moduleMapPath",
                        "-I$generatedModuleMapsDirPath",
                        "-F$productsDirPath",
                        "-F$packageFrameworksDirPath"
                    )
                    includeDirs(generatedModuleMapsDir.get().asFile)
                    includeDirs(productsDir.get().asFile)
                    includeDirs(productsDir.get().dir("PackageFrameworks").asFile)
                }
                tasks.named(cinterop.interopProcessingTaskName).configure {
                    if (isSimulator) {
                        dependsOn(buildAppleBridgeSimulator)
                    } else {
                        dependsOn(buildAppleBridgeDevice)
                    }
                }
            }
        }
    }
}
